# Task 2: Kubernetes Deployment

# Introduction

This document provides instructions on how to use the Kubernetes configuration files developed for deploying the Go application.

## Resources

The templates contain the following Kubernetes resources:

- [Namespace](./templates/namespace.yaml): The namespace where the application will be deployed.
- [Deployment](./templates/deployment.yaml): The deployment of the application.
- [Service](./templates/service.yaml): The service that exposes the application.
- [Ingress](./templates/ingress.yaml): The ingress that exposes the application to the outside world.
- [Secret](./templates/secret.yaml): The secret of the application.
- [ConfigMap](./templates/configmap.yaml): The configuration of the application.
- [PersistentVolumeClaim](./templates/persistentvolumeclaim.yaml): The persistent volume claim of the application.
- [Job](./templates/job.yaml): The job that runs the database migrations.
- [CronJob](./templates/cronjob.yaml): The cron job that runs the database backups.
- [HorizontalPodAutoscaler](./templates/horizontalpodautoscaler.yaml): The horizontal pod autoscaler that scales the application based on CPU usage.
- [PodDisruptionBudget](./templates/poddisruptionbudget.yaml): The pod disruption budget that ensures that at least one pod is available at all times.
- [NetworkPolicy](./templates/networkpolicy.yaml): The network policy that restricts access to the application.
- [PodSecurityPolicy](./templates/podsecuritypolicy.yaml): The pod security policy that restricts the privileges of the application.
- [Role](./templates/role.yaml): The role that defines the permissions of the application.
- [RoleBinding](./templates/rolebinding.yaml): The role binding that binds the role to the service account.
- [ServiceAccount](./templates/serviceaccount.yaml): The service account that is used by the application.
- [PodSecurityPolicy](./templates/podsecuritypolicy.yaml): The pod security policy that restricts the privileges of the application.

The Deployment uses the Docker image built in the previous step and includes a [readiness/liveness probe](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/), a [pre-stop hook](https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/), and an [init container](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/) that sleeps for 30 seconds before the application starts, to ensure that the MySQL database is ready before the application starts.

## Liveness and Readiness Probes

Some modifications were done to the [webserver.go](./webserver.go) file to include endpoints for the readiness/liveness probes and the pre-stop hook.

For the liveness probe, the application is considered healthy if it returns a 200 status code in the `/health` endpoint. For the readiness probe, the application is considered ready if it returns a 200 status code in the same endpoint and the database connection is ready.**

## Lifecycle Hooks

The lifecycle hooks are loaded into the Pod via ConfigMap volumes and those volumes are mounted as files in the container. The [templates/config/hooks](./templates/server.confi) folder contains the hooks that will be automatically generated by Kustomize and mounted in the container. 

The [templates/config/hooks/pre-stop.sh](./templates/server.confi/pre-stop.sh) file contains the pre-stop hook that will be executed when the pod is terminated. The [templates/config/hooks/health.sh](./templates/server.confi/health.sh) file contains the health check that will be used by the liveness and readiness probes.

The post-start hook is used to override the database connection string in the application. The connection string is read from the `/etc/config/db-connection-string` file and the application is considered ready if the file exists and is not empty.

The pre-stop hook is used to gracefully shutdown the application when the pod is terminated. The application is considered ready to be terminated if it returns a 200 status code in the `/health` endpoint.

## Using Kustomize, Volume Mounts and Lifecycle Hooks to override the Database Connection String

Only to illustrate how to use [Kustomize's Secret Generator](https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-kustomize/) along with [Volume Mounts](https://kubernetes.io/docs/concepts/storage/volumes/) and [Lifecycle Hooks](https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/) to override the database connection string, it was stored in the [templates/server.confi](./templates/server.confi) file, which is used by Kustomize to generate a Secret that will be mounted as a Volume in the Deployment to override the original value from the image. The connection string is then read by the Go app as usual. 

## Getting Started
The instructions below provide a step-by-step guide for setting up the application in a local Kubernetes cluster.

## Prerequisites

- [Minikube](https://minikube.sigs.k8s.io/docs/start/)
- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/)

## Instructions

1. **Start Minikube**: Start your local Minikube cluster by running the command `minikube start`.

2. **Deploy the templates**: Deploy all the files in the [.kubernetes](./templates) folder with [kubectl kustomize](https://kubernetes.io/docs/tasks/manage-kubernetes-objects/kustomization/) to deploy the whole stack in your cluster from the kubernetes folder with the following command:

    ```bash
    kubectl apply -k templates
    ```

3. **Verify the Deployment and Service**: You can verify that the Deployment and Service were created successfully by running the following commands:

    ```bash
    kubectl get deployments -n stack-io
    kubectl get services -n stack-io
    ```

4. **Access the Application**: If everything was set up correctly, you should be able to access the application by forwarding a port from your local machine to the Service in the cluster:

    ```
    kubectl port-forward svc/stack-io 8083:8080 -n stack-io
    ```

The application should now be accessible at http://localhost:8083.

## Prerequisites

Before you begin, you will need to install the following tools:

- [Minikube](https://minikube.sigs.k8s.io/docs/start/)
- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/)

## Installation

To install the application, follow these steps:

1. Start your local Minikube cluster by running the command `minikube start`.
2. Apply the `namespace.yaml` file to create a new namespace in your cluster:

    ```bash
    kubectl apply -f namespace.yaml
    ```

3. Apply the `app.yaml` file to create a new Deployment and Service in your cluster:

    ```bash
    kubectl apply -f app.yaml
    ```

4. Verify that the Deployment and Service were created successfully by running the following commands:

    ```bash
    kubectl get deployments -n stack-io
    kubectl get services -n stack-io
    ```

5. Forward a port from your local machine to the Service in the cluster:

    ```bash
    kubectl port-forward svc/stack-io 8083:8080 -n stack-io
    ```

6. Access the application by navigating to http://localhost:8083 in your web browser.

## Usage

To use the application, simply navigate to http://localhost:8083 in your web browser. The application should be up and running.

## Future Development

In the future, Kubernetes configuration files will be updated to improve the application's performance and scalability.

# Task 2: Kubernetes
### Exercise Goals

* Install minikube;
* Create namespace;
* Create deployment;
  * Use the golang webserver image you built in the previous step;
  * Add readiness/livess probe;
  * Add prestophook;
  * add init container that sleep for 30 seconds;
* Create service to expose your pod;

### Expected Output

Please, provide us with a file named `namespace.yaml` you are going to create. Your `namespace.yaml` is supposed to:
* Contain the following Kubernetes Resources you are going to create in your `minikube` cluster:
  * Namespace specification;

Please, provide us with a file named `app.yaml` you are going to create. Your `app.yaml` is supposed to:
* Contain the following Kubernetes Resources you are going to create in your `minikube` cluster:
  * Deployment specification;
    * Use your new image created on the [Task 1](../dockerize) in your deployment;
  * Service specification;

[Optional] You can also share screenshots of your progress.

### Next steps?

Once you complete this task, you can proceed to the [Terraform](../terraform) task;
